# Lessons learned - Azure DevOps pipelines + .NET + SonarQube

## Gotchas
### `dotnet tool`
- dotnet tool install gotcha for Linux regarding "workingDirectory"
- NOTE: We need to set the workingDirectory to an arbitrary folder (e.g. "Scripts")
- that does not have any .NET projects in it, because the .NET Core CLI will
- automatically restore any .NET projects in the working directory.

### "PublishPipelineArtifact" task
- PublishPipelineArtifact@1 doesn't flatten folders
- i.e. if you download an artifact "MyCoolArtifact1" &  "MyCoolArtifact2" with some arbitrary files into "MyFolder", then it will result in MyFolder/MyCoolArtifact1/... & MyFolder/MyCoolArtifact1/...
- We can potentially solve this by using the "CopyFiles@2" task w/ the `flattenFolders` parameter set to true

### "CopyFiles" task
- CopyFiles@2 task gotcha when trying to copy specific file types using "Contents":
- https://stackoverflow.com/a/70874760

### Installing new software on a self-hosted agent
- Installing new software on an self-hosted agent (like a dotnet tool) during a build could lead to you needing to restart the agent
- See: https://stackoverflow.com/a/62712205

## Performance
### "PublishCodeCoverageResults" task
- The "PublishCodeCoverageResults@1" is incredibly slow...
  - https://github.com/microsoft/azure-pipelines-tasks/issues/4945
  - Basically makes it unusable.
  - But publishing directly from the "DotNetCoreCLI@2" task is much, much faster (I don't know why this is)

## Code coverage
- https://github.com/microsoft/azure-pipelines-tasks/issues/4945

- https://docs.sonarsource.com/sonarqube/9.9/analyzing-source-code/test-coverage/dotnet-test-coverage/#visual-studio-code-coverage
- We only recommend the use of this tool when the build agent has Visual Studio Enterprise installed or when you are using an Azure DevOps Windows image for your build. In these cases, the .NET Framework 4.6 scanner will automatically find the coverage output generated by the --collect "Code Coverage" parameter without the need for an explicit report path setting. It will also automatically convert the generated report to XML. No further configuration is required. Here is an example:

- The "Cobertura" code coverage format doesn't work together with C# for SonarQube...?

- PublishTestResults@2 together w/ Karma (JS) tests
- We need one format for the JUnit test that is compatible w/ Azure DevOps and another that is compatible with SonarQube
- karma-junit-reporter
- karma-sonarqube-unit-reporter

### Code coverage results in PRs in Azure DevOps
- https://learn.microsoft.com/en-us/azure/devops/pipelines/test/codecoverage-for-pullrequests?view=azure-devops
- https://learn.microsoft.com/en-us/azure/devops/pipelines/test/codecoverage-for-pullrequests?view=azure-devops#which-coverage-tools-and-result-formats-can-be-used-for-validating-code-coverage-in-pull-requests

### 
## SonarQube

## Local NuGet feed
- no-build, no-restore, vsts-feed

## .NET
### Implicit restore & build
- https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build#implicit-restore

### "pathtoCustomTestAdapters"
- "pathtoCustomTestAdapters" for VSTest task:
- Required when building a solution with both .NET Core & .NET Framework-based test projects
- Use the "pathtoCustomTestAdapters" property to point to one of the .NET Framework-projects, like so:
- pathtoCustomTestAdapters: "Tests/Internal/Viedoc.Worker.Tests/bin/Release/net472/"

## Pipeline templates
### Conditions for templates
```
${{ if ne(variables['Build.Reason'], 'PullRequest') }}
```

## Tests run in pipeline that require "Azurite"
```
      # Azurite is required for some tests to run as expected
      # See: https://learn.microsoft.com/en-us/samples/azure-samples/automated-testing-with-azurite/automated-testing-with-azure/
      - bash: |
          npm install -g azurite
          mkdir azurite
          azurite --silent --location azurite &
        displayName: "Install and Run Azurite"
```
